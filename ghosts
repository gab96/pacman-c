//levels
#define base 1
#define med 2
#define hard 3
int g_level;

//sprite
#define ghost1 " ooo "
#define ghost2 "ooooo"
#define ghost3 "o o o"

//set of colors
#define color[4]={0x22, 0x88, 0xCC, 0xFF};

//movement
int BFS(bool mode){
	
}

void g_print(int n, int dir){
	textattr(0x00);
	gotoxy(g_coor[n].x,g_coor[n].y);
	cout<<ghost1;
	gotoxy(g_coor[n].x,g_coor[n].y+1);
	cout<<ghost2;
	gotoxy(g_coor[n].x,g_coor[n].y+2);
	cout<<ghost3;
	switch(dir){
		case 1: g_coor[n].x--; break;
		case 2: g_coor[n].y--; break;
		case 3:	g_coor[n].x++; break;
		case 4:	g_coor[n].y++; break;
	}
	if(!powerup){
		textattr(color[n]);
		gotoxy(g_coor[n].x,g_coor[n].y);
		cout<<ghost1;
		gotoxy(g_coor[n].x,g_coor[n].y+1);
		cout<<ghost2;
		gotoxy(g_coor[n].x,g_coor[n].y+2);
		cout<<ghost3;
	}
	else{//when fleeing the ghosts turn blue
		textattr(0x11);
		gotoxy(g_coor[n].x,g_coor[n].y);
		cout<<ghost1;
		gotoxy(g_coor[n].x,g_coor[n].y+1);
		cout<<ghost2;
		gotoxy(g_coor[n].x,g_coor[n].y+2);
		cout<<ghost3;
	}
	switch(dir){//if the ghost was on a point, print it back
		case 1:
			if(map_points[g_coor[n].x+5][g_coor[n].y+1]){
				gotoxy(g_coor[n].x+4,g_coor[n].y+1);
				textattr(0xFF);
				cout<<"o"
			}
			break;
		case 2:
			if(map_points[g_coor[n].x+2][g_coor[n].y+3]){
				gotoxy(g_coor[n].x+4,g_coor[n].y+1);
				textattr(0xFF);
				cout<<"o"
			}
			break;
		case 3:
			if(map_points[g_coor[n].x-1][g_coor[n].y+1]){
				gotoxy(g_coor[n].x+4,g_coor[n].y+1);
				textattr(0xFF);
				cout<<"o"
			}
			break;
		case 4:
			if(map_points[g_coor[n].x+2][g_coor[n].y-1]){
				gotoxy(g_coor[n].x+4,g_coor[n].y+1);
				textattr(0xFF);
				cout<<"o"
			}
			break;
	}
	g_lastmove[n]=dir;
	if(last_seen.x>=g_coor[n].x && last_seen.x<=g_coor[n].x+4 && last_seen.y>=g_coor[n].y && last_seen.y<=g_coor[n].y+2)
		last_seen={0,0};//if the last seen location is reached, it gets reset
}

int g_lastmove[4];//1 left, 2 up, 3 right, 4 down, 0 -

//behavior functions
void g_playstyle(){
	bool check=true;
	for(int n=0; n<4; n++){
		if(g_spawntimer[n]!=-1)//skips turn if the n-ghost is waiting for respawn
			continue;
		if(powerup)//if the ghosts are fleeing
			g_print(n, BFS(false));
		else if(g_level==hard)//HARD-ONLY: grants global vision at any time
			last_seen={x_pac,y_pac};
		else if(!g_sight() && last_seen.x==0 && last_seen.y==0){//if there's no path to follow
			if(g_level==med){//MEDIUM-ONLY: follows a path of eaten points rather than moving randomly
				for(int i=0; i<4; i++){
					int tempx, tempy;
					int ran=rand()%4+1;
					switch(ran){
						case 1:
							tempx=g_coor[n].x-1;
							tempy=g_coor[n].y+1;
							break;
						case 2:
							tempx=g_coor[n].x+1;
							tempy=g_coor[n].y-1;
							break;
						case 3:
							tempx=g_coor[n].x+5;
							tempy=g_coor[n].y+1;
							break;
						case 4:
							tempx=g_coor[n].x+1;
							tempy=g_coor[n].y+3;
							break;
					}
					if(!map_points[tempx][tempy])
						g_print(n, ran);
				}
			}
			switch(g_lastmove[n]){
				case 1://left
					for(int i=0; i<3, i++){
						coord temp={g_coor[n].x-1, g_coor[n].y+i};//checks if the old direction is viable
						wallghost=true;
						if(wall(temp)){
							check=false;
							break;
						}
						else if(i==2)
							g_print(n, g_lastmove[n]);//keeps the same direction
					}
					break;
				case 2://up
					for(int i=0; i<5, i++){
						coord temp={g_coor[n].x+i, g_coor[n].y-1};//checks if the old direction is viable
						wallghost=true;
						if(wall(temp)){
							check=false;
							break;
						}
						else if(i==4)
							g_print(n, g_lastmove[n]);//keeps the same direction
					}
					break;
				case 3://right
					for(int i=0; i<3, i++){
						coord temp={g_coor[n].x+5, g_coor[n].y+i};//checks if the old direction is viable
						wallghost=true;
						if(wall(temp)){
							check=false;
							break;
						}
						else if(i==2)
							g_print(n, g_lastmove[n]);//keeps the same direction
					}
					break;
				case 4://down
					for(int i=0; i<5, i++){
						coord temp={g_coor[n].x+i, g_coor[n].y+3};//checks if the old direction is viable
						wallghost=true;
						if(wall(temp)){
							check=false;
							break;
						}
						else if(i==4)
							g_print(n, g_lastmove[n]);//keeps the same direction
					}
					break;
				default: check=false;
			}
			if(!check){
				srand(time(NULL));
				for(int d=0; d<4; d++){ 
					wallghost=true;
					int g_dir=rand()%4+1
					switch(g_dir){
						case 1://left
							for(int i=0; i<3; i++){
								coord temp={g_coor[n].x-1, g_coor[n].y+i};
								if(wall(temp))
									break;
								else if(i==2){
									check=true;
									g_print(n, g_dir);
								}
							}
							break;
						case 2://up
							for(int i=0; i<5; i++){
								coord temp={g_coor[n].x+i, g_coor[n].y-1};
								if(wall(temp))
									break;
								else if(i==4){
									check=true;
									g_print(n, g_dir);
								}
							}
							break;
						case 3://right
							for(int i=0; i<3; i++){
								coord temp={g_coor[n].x+5, g_coor[n].y+i};
								if(wall(temp))
									break;
								else if(i==2){
									check=true;
									g_print(n, g_dir);
								}
							}
							break;
						case 4://down
							for(int i=0; i<5; i++){
								coord temp={g_coor[n].x+i, g_coor[n].y+3};
								if(wall(temp))
									break;
								else if(i==4){
									check=true;
									g_print(n, g_dir);
								}
							}
							break;
					}
					if(!check && d=3)
						g_print(n, 0);
				}
			}
		}
		if(last_seen.x!=0 && last_seen.y!=0)//if there's a location to check
			g_print(n, BFS(true));
	}
}

bool g_sight(){//checks whether pacman is within a ghost's line of sight
	coord temp;
	for(int i=0; i<3; i++){//x-axis
		for(int e=4;;e++){
			temp={g_coor[n].x+i+e,g_coor[n].y};
			if(see(temp)){
				track(n)
				return true;//pacman has been located
			}
			if(wall(temp))
				continue;//vision doesn't pass through walls
		}
		for(int e=0;;e--){
			temp={g_coor[n].x+i+e,g_coor[n].y};
			if(see(temp)){
				track(n)
				return true;
			}
			if(wall(temp))
				continue;
		}
	}
	for(int i=0; i<5; i++){//y-axis
		for(int e=2;;e++){
			temp={g_coor[n].x,g_coor[n].y+i+e};
			if(see(temp)){
				track(n)
				return true;
			}
			if(wall(temp))
				continue;
		}
		for(int e=0;;e--){
			temp={g_coor[n].x,g_coor[n].y+i+e};
			if(see(temp)){
				track(n)
				return true;
			}
			if(wall(temp))
				continue;
		}
	}
	return false;
}

//see pac/wall
bool see(coord coo){
	for(int i=0; i<5; i++)
		for(int j=0; j<3; j++)
			if(coo.x==(x_pac+i) && coo.y==(y_pac+j)){//checks for any of pacman's pixels
				return true;
				last_seen={x_pac+i,y_pac+j};//updates last seen location
			}
	return false;
}

bool wall(coord coo){
	char t=map[coo.x][coo.y];
	if(wallghost){//if this is used to check for others ghosts as well
		wallghost=false;
		if(G_WALL || G_GHOST)//check for walls/ghosts
			return true;
	}
	else
		if(G_WALL)
			return true;
	return false;
}

bool wallghost;//determines if wall checks just for walls or for ghosts too

//wall/ghost collision condition	
#define G_WALL t==WALL_VER||t==WALL_HOR||t==CORNER_UPPERLEFT||t==CORNER_UPPERRIGHT||t==CORNER_BOTTOMLEFT||t==CORNER_BOTTOMRIGHT
#define G_GHOST  (coo.x>=g_coor[0].x && coo.x<=g_coor[0].x+4 && coo.y>=g_coor[0].y && coo.y<=g_coor[0].y+2) || (coo.x>=g_coor[1].x && coo.x<=g_coor[1].x+4 && coo.y>=g_coor[1].y && coo.y<=g_coor[1].y+2) || (coo.x>=g_coor[2].x && coo.x<=g_coor[2].x+4 && coo.y>=g_coor[2].y && coo.y<=g_coor[2].y+2)  || (coo.x>=g_coor[3].x && coo.x<=g_coor[3].x+4 && coo.y>=g_coor[3].y && coo.y<=g_coor[3].y+2)
		//^checks the coordinates of every ghost

//coordinates
typedef struct g_coo{
	int x;
	int y;
}coord;
coord g_coor[4];
coord last_seen;

//respawn system
int n_ghost;
int g_spawntimer[4];
#define g_tBASE 6
#define g_tMED 4	//respawn timers
#define g_tHARD 2
void g_spawn(){//WIP
	for(int i=0; i<4; i++){
		if(g_spawntimer[i]==0){//spawn when timer reachs 0
			//spawn
		}
		if(g_spawntimer[i]>=0)//subtracts 1 from spawn timer/sets already spawned to -1
			g_spawntimer[i]--;
	}
}

//needings/references
bool map_points[ROWS][COL];
